from io import StringIO
from typing import Any, AnyStr, IO, Optional, Text, Tuple, Union, overload
from typing_extensions import Final
import sys

if sys.version_info < (3, 0):
    class TextIO(StringIO):
        def write(self, data: Union[str, unicode]) -> None: ...
else:
    TextIO = StringIO

if sys.version_info < (3, 0):
    class BytesIO(StringIO):
        def write(self, data: bytes) -> None: ...
else:
    from io import BytesIO as BytesIO

class FDCapture:
    def __init__(self, targetfd: TODO, tmpfile: Optional[TODO] = ..., now: bool = ..., patchsys: bool = ...) -> None: ...
    def start(self) -> None: ...
    def done(self) -> TODO: ...
    def writeorg(self, data: TODO) -> None: ...

class StdCaptureFD:
    def __init__(self, out: TODO = ..., err: TODO = ..., mixed: TODO = ..., in_: TODO = ..., patchsys: TODO = ..., now: TODO = ...) -> None: ...
    @classmethod
    def call(cls, func: TODO, *args: TODO, **kwargs: TODO) -> Tuple[TODO, TODO, TODO]: ...
    def reset(self) -> Tuple[TODO, TODO]: ...
    def suspend(self) -> TODO: ...
    def startall(self) -> None: ...
    def resume(self) -> None: ...
    def done(self, save: bool = ...) -> Tuple[TODO, TODO]: ...
    def readouterr(self) -> Tuple[TODO, TODO]: ...

class StdCapture:
    def __init__(self, out: TODO = ..., err: TODO = ..., in_: TODO = ..., mixed: TODO = ..., now: TODO = ...) -> None: ...
    @classmethod
    def call(cls, func: TODO, *args: TODO, **kwargs: TODO) -> Tuple[TODO, TODO, TODO]: ...
    def reset(self) -> Tuple[TODO, TODO]: ...
    def suspend(self) -> TODO: ...
    def startall(self) -> None: ...
    def done(self, save: bool = ...) -> Tuple[TODO, TODO]: ...
    def resume(self) -> None: ...
    def readouterr(self) -> Tuple[TODO, TODO]: ...

# XXX: The type here is not exactly right. If f is IO[bytes] and
# encoding is not None, returns some weird hybrid, not exactly IO[bytes].
def dupfile(
    f: IO[AnyStr],
    mode: Optional[str] = ...,
    buffering: int = ...,
    raising: bool = ...,
    encoding: Optional[str] = ...,
) -> IO[AnyStr]: ...
def get_terminal_width() -> int: ...
def ansi_print(
    text: Union[str, Text],
    esc: Union[Union[str, Text], Tuple[Union[str, Text], ...]],
    file: Optional[IO[AnyStr]] = ...,
    newline: bool = ...,
    flush: bool = ...,
) -> None: ...
def saferepr(obj, maxsize: int = ...) -> str: ...

class TerminalWriter:
    stringio: TextIO
    encoding: Final[str]
    hasmarkup: bool
    def __init__(self, file: Optional[IO[str]] = ..., stringio: bool = ..., encoding: Optional[str] = ...) -> None: ...
    @property
    def fullwidth(self) -> int: ...
    @fullwidth.setter
    def fullwidth(self, value: int) -> None: ...
    @property
    def chars_on_current_line(self) -> int: ...
    @property
    def width_of_current_line(self) -> int: ...
    def markup(
        self,
        text: str,
        *,
        black: int, red: int, green: int, yellow: int, blue: int, purple: int, cyan: int, white: int, Black: int, Red: int,
        Green: int, Yellow: int, Blue: int, Purple: int, Cyan: int, White: int, bold: int, light: int, blink: int, invert: int,
    ) -> str: ...
    def sep(
        self,
        sepchar: str,
        title: Optional[str] = ...,
        fullwidth: Optional[int] = ...,
        *,
        black: int, red: int, green: int, yellow: int, blue: int, purple: int, cyan: int, white: int, Black: int, Red: int,
        Green: int, Yellow: int, Blue: int, Purple: int, Cyan: int, White: int, bold: int, light: int, blink: int, invert: int,
    ) -> None: ...
    def write(
        self,
        msg: str,
        *,
        black: int, red: int, green: int, yellow: int, blue: int, purple: int, cyan: int, white: int, Black: int, Red: int,
        Green: int, Yellow: int, Blue: int, Purple: int, Cyan: int, White: int, bold: int, light: int, blink: int, invert: int,
    ) -> None: ...
    def line(
        self,
        s: str = ...,
        *,
        black: int, red: int, green: int, yellow: int, blue: int, purple: int, cyan: int, white: int, Black: int, Red: int,
        Green: int, Yellow: int, Blue: int, Purple: int, Cyan: int, White: int, bold: int, light: int, blink: int, invert: int,
    ) -> None: ...
    def reline(
        self,
        line: str,
        *,
        black: int, red: int, green: int, yellow: int, blue: int, purple: int, cyan: int, white: int, Black: int, Red: int,
        Green: int, Yellow: int, Blue: int, Purple: int, Cyan: int, White: int, bold: int, light: int, blink: int, invert: int,
    ) -> None: ...
